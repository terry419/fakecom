# **게임 기획 문서 (GDD)**

## **1.0. 게임 개요 (Game Overview)**

* 장르 : 액티브 턴제 전술(전략적 판단, 피지컬 조작, 육성의 결합)  
* 컨셉 : 전략적인 배치와 수는 두되, 전투의 결과는 주사위에만 영향을 받는 것이 아닌 플레이어의 기술도 영향을 줄 수 있는 능동형 전술 게임.  
* **시점 :** **쿼터뷰 (Quarter View) 자유 시점.**  
  * *조작:* 마우스 우클릭 드래그를 통해 360도 자유롭게 회전 가능.  
* 시점 :  쿼터 뷰.(Free Rotation. 마우스 우클릭)  
* 플랫폼 : Unity 3D 엔진(URP환경)으로 제작. PC 출시 후 게임 패드 및 모바일 이식.  
* 타겟 :   어려운 난이도를 즐기지만 결과가 운에 의해 결정되는 것을 싫어하며, 수동적인 턴제의 진행 방식 대신 피지컬로 직접 개입하기를 원하는 유저.  
* **그래픽 컨셉 (Art) :** **다크 리얼리스틱 로우 폴리 (Dark Realistic Low Poly).**  
  * **형태는 단순하지만(Low Poly), 어둡고 무거운 조명과 안개 효과(URP)를 활용하여 디스토피아의 황량하고 압도적인 분위기를 연출함.**  
* **사운드 컨셉 (Audio) : 건조한 리얼리즘 (Dry Realism).**  
  * **웅장한 BGM은 배제하고, 앰비언트(바람 소리, 기계음) 위주로 구성.**  
  * **발소리, 호흡음, 총기 격발음, 피격음 등 전투 SFX를 극도로 강조하여 현장감 극대화.**


## **2.0. 핵심 게임 플레이 루프 (Core Gameplay Loop)**

### **2.1. 매크로 루프 (Macro Loop: 기지 관리 및 성장)**

플레이어는 엔딩을 볼 때까지, 전장에서 수집한 \*\*'잡동사니(Junk)와 부품'\*\*을 활용해 폐허가 된 기지를 재건하고 전력을 강화한다.

1\. 기지 관리 (Management Phase)

플레이어는 획득한 자원을 바탕으로 다음 시설들을 이용 및 강화한다.

* 기술소 (Tech Lab) \- \[핵심: Hideout System\]  
  * 역할: 기지 내 모든 시설의 기능을 확장하고 물리적으로 강화하는 건설/제작 허브.  
  * 방식: 단순 재화 소모가 아니라, \*\*전장에서 루팅한 특정 재료(전선, 금속판, 회로기판 등)\*\*를 직접 소모하여 시설 모듈을 건설함.  
  * 효과: 모듈 건설 시 해당 시설(의무실, 훈련소 등)의 기능이 영구적으로 향상됨.  
* 암시장 (Black Market) \- \[핵심: Exchange\]  
  * 역할: 자원 수급 불균형을 해소하는 물물교환 거래소.  
  * 기능: 남아도는 잡동사니를 팔아 자금을 확보하거나, 기지 확장에 필수적인 \*\*'희귀 부품'\*\*을 비싼 값에 구매/교환.  
* 병영 (Barracks)  
  * 대원 고용, 스쿼드 편성, 대원 상세 정보 확인.  
* 훈련소 (Training Grounds)  
  * 전투에 나가지 않는 대기 인원에게 경험치를 제공하거나 특성을 교정. (기술소 업그레이드에 따라 효율 상승)  
* 의무실 (Medical Bay)  
  * 부상당한 대원을 배치하여 체력 및 부상(트라우마) 회복. (기술소에서 침대 증설 시 수용 인원 증가)  
* 연구실 (Research Lab)  
  * 적의 '데이터(Data)'를 분석하여 기술적 해금 요소(신규 장비, 소모품 레시피)를 연구. (초반 잠금 $\\rightarrow$ 미션 진행 후 해금)  
* 기억의 방 (Memorial)  
  * 사망한 대원들의 기록(이름, 계급, 킬 수, 사망 원인)을 열람하고 추모.  
* 작전 통제실 (Operations Center)  
  * 월드맵을 통해 다음 수행할 미션(난이도, 보상, 적 유형)을 선택.  
* 수리공방 (Repair Shop)  
  *  **역할:** 전투에서 획득한 '손상된 장비'를 수리하여 사용 가능한 상태로 복구하는 시설.  
  * **기능:** 루팅된 무기는 기본적으로 '파손(Damaged)' 상태이며, 일정 자재(Junk)와 자금을 소모하여 수리해야 유닛에게 장착할 수 있습니다.

2\. 출격 준비 (Provision)

* 미션 시작 직전, 자금을 소모하여 이번 작전에 필요한 \*\*소모품(탄약, 수류탄, 회복 키트, 주사기 등)\*\*을 구매하고 인벤토리에 배분.  
* **Player Spawn Point**와 **Enemy Spawn Point**를 맵 데이터(`LevelDataSO`)에서 어떻게 가져와 배치할지 로직필요

3\. 전술 전투 (Tactical Combat)

* 적 제압뿐만 아니라, 맵 곳곳에 흩어진 \*\*'건축 자재(Loot)'\*\*를 확보하는 것이 중요한 전술적 목표가 됨.

4\. 결과 및 결산 (Result)

* 생존 대원 복귀 및 부상 처리.  
* 사망 시 장비 및 스탯 영구 소실.  
* 획득한 \*\*재료 아이템(Junk)\*\*을 기지 창고에 저장.

  #### 2.2. 마이크로 루프 (Micro Loop: 전투 턴 흐름)

유니티의 TurnManager가 처리하게 될 1개 단위 턴의 로직 흐름.

* 1단계: 정보 수집 (Assessment): 플레이어는 360도 회전 카메라로 전장 상황(적 위치, 엄폐, 고저차) 파악.  
* 2단계: 행동 결정 및 계산 (Calculation): 이동 및 타겟 지정. 시스템은 사격 각도, 고저차, 실내/외 여부를 종합하여 '최종 명중률'과 '입력 난이도' 산출.  
* 3단계: 액션 실행 (Execution): 무기에 할당된 QTE 모듈(Timing, Hold, Focus) 팝업 및 입력 수행.  
* 4단계: 결과 적용 (Application): 최종 데미지 적용, 연출 재생, 행동 기회 소진 시 턴 종료.  
* 5단계: 적 반응 (Reaction): 적 턴에 아군 피격 시, \[위기 판정(치명타/사망)\] 조건 충족 시 방어 QTE 발동.

## **3.0. 세계관 및 시나리오 (World View & Scenario)**

### **3.1. 배경 (Background)**

* **디스토피아 SF:** 인류는 과도한 욕심과 자원 분쟁으로 인한 핵전쟁으로 이미 멸망함.  
* **AI의 목적:** 인류 멸망 후 남겨진 관리 AI는 '인간 복제 기술'을 연마하여 인간 세상을 재건하고, 그 위에 신처럼 군림하려 함.

### **3.2. 스토리텔링 구조 (Narrative Structure)**

표면적인 영웅 서사(Layer A)와 그 이면에 숨겨진 진실(Layer B)을 이중으로 전개한다.

**(1) Layer A: 표면적 설정 (Surface)**

* **설정:** 플레이어는 AI의 압제에 저항하는 '인간 레지스탕스'의 지휘관.  
* **전달 방식:** \*\*오퍼레이터(부관)\*\*의 비장한 브리핑.

**(2) Layer B: 실제 설정과 진실 (Hidden Truth)**

* **진실:** 플레이어 또한 AI가 보관 중인 **'통 속의 뇌(Brain in a Vat)'** 상태이며, 시뮬레이션 속에서 전술 데이터를 생성하기 위해 끝없는 전투를 반복하는 실험체.  
* **전달 방식:** 전장에서 수집하는 **\[로그 데이터 (Logs)\]**.  
* **로그 내용 (작성자 원문):**  
  * *"이상하다, 요즘 무언가 공허한 느낌이 들고 있다. 전쟁에 감정이 메말라 가는 것인가?"*  
  * *"얼마 전 어릴적부터 함께 해 온 강아지가 죽었다. 분명 슬프지만 눈물이 나지 않았다. 아니 슬프기는 한 것이 맞을까?"*  
  * *"옛날 SF 소설을 읽어보니 통속의 뇌와 같은 이야기를 읽었다. 핫 유치하기 짝이 없군. 때로는 생각한다 이런 지옥 속에서 사느니 통속의 뇌가 되는 것이 낫지 않을까? AI님 기왕이면 미녀 100명 정도 아내로 해서 실험해달라고\~ 그럼 당장 이 지긋지긋한 레지스탕스도 때려치지."*

### **3.3. 적의 정체 (Antagonist)**

* **설정:** AI가 보낸 치안 유지 로봇 및 변이된 생명체들.  
* **진실:** 이들은 인류를 멸망으로 몰고 갔다고 여겨지는 **'욕심', '질투', '분노'** 등의 감정이 데이터화되어 실체화된 존재들임.  
* **AI의 의도:** AI는 플레이어가 이들을 제압하는 과정을 통해 \*\*'불필요한 요소가 거세된 완전한 인간'\*\*의 알고리즘을 완성하려 함.

### **3.4. 결말 (Ending)**

* **진실의 대면:** 마침내 AI를 쓰러트린 주인공은 이 모든 것이 가상임을 깨닫고, AI는 플레이어를 통 속의 뇌에서 꺼내어 육체를 줌.  
* **최후의 선택:** 플레이어는 다음의 두 가지 층위에서 선택을 해야 함.  
  1. **AI에 대한 심판:** AI를 파괴할 것인가, 파괴하지 않을 것인가. (AI의 행동을 이성적으로 용인할 것인가, 부정할 것인가)  
  2. **자아의 선택:** 스스로를 파괴할 것인가, AI의 의도대로 살아남을 것인가. (AI의 요구에 순응하며 세뇌된 채 살아갈 것인가, 아니면 AI의 요구를 부수기 위해 자신의 목숨까지 포기할 것인가)  
     

## **4.0. 캐릭터 및 병과 시스템 (Character & Class System)**

*캐릭터의 성장은 \*\*'개인의 경험(Level)'\*\*과 **'기술의 발전(Research)'** 두 축으로 나뉜다.*

### **4.1. 기본 스탯 (Base Stats)**

*유닛은 다음의 핵심 능력치를 가지며, 일부는 내부 로직으로만 작동한다.*

* ***HP (체력):** 0이 되면 사망(영구적 죽음).*  
* ***Mobility (이동력):** 한 턴에 이동할 수 있는 타일 수.*  
* ***Aim (명중률):** 공격 시 액티브 미니게임의 **\[성공 영역(녹색/노랑)\]** 크기를 결정.*  
* ***Evasion (회피율):** 피격 시 발동하는 \*\*\[방어 QTE\]\*\*의 난이도(입력 시간/키 개수)를 결정.*  
* ***Action/Move Count (내부 변수):** UI에는 표시되지 않으나, 시스템적으로 '이동 1회, 공격 1회'의 행동 기회를 제어하는 내부 변수.*

### **4.2. 병과 및 전용 무기 (Class & Weapon)**

*각 병과는 고유한 무기 기믹(QTE)과 4번(투척), 5번(특수기) 슬롯에 배정된 고유 기술을 가진다.*

***(1) 돌격병 (Assault)***

* ***역할:** 중거리 딜러.*  
* ***무기 기믹: \[Hold & Release\]***  
  * ***UI 디자인:** 수평 게이지 (Horizontal Bar) \- 왼쪽에서 오른쪽으로 차오르는 게이지.*  
  * ***조작 방식:** 버튼을 누르면 게이지가 빠르게 **상승 하강 반복**, \*\*\[성공 영역\]\*\*에서 버튼을 뗌.*  
* ***고유 기술:***  
  * ***\[Slot 4\] 파편 수류탄 (Frag):** (기본 범위 폭발).*  
  * ***\[Slot 5\] 제압 사격 (Suppression):** 기본 데미지 \+ **이동력 0 (이동 불가)** 부여. 쿨타임 적용.*

***(2) 저격병 (Sniper)***

* ***역할:** 원거리 누킹.*  
* ***무기 기믹: \[Focus Aim\]***  
  * ***UI 디자인:** 스코프 뷰 (Scope Circle) \- 화면 중앙 십자선과 흔들리는 조준원.*  
  * ***조작 방식:** 마우스/스틱으로 흔들리는 원을 중앙에 유지하며 시간 버티기.*  
* ***고유 기술:***  
  * ***\[Slot 4\] 화염병/지뢰 (Area Denial):** 지역 장악용 투척 무기.*  
  * ***\[Slot 5\] 권총 사격 (Pistol Shot):** 중간 데미지, 짧은 사거리. **턴 강제 종료 없음**.*

***(3) 스카웃 (Scout)***

* ***역할:** 정찰(시야 확보).*  
* ***무기 기믹: \[Timing Hit\]***  
  * ***UI 디자인:** **원형 링 (Radial Ring)**.*  
  * ***조작 방식:** 시계 방향으로 회전하는 바늘이 \*\*\[성공 영역\]\*\*을 지날 때 버튼 클릭 (리듬게임 스타일).*  
* ***고유 기술:***  
  * ***\[Slot 4\] 스캔 수류탄 (Scan):** 시야 확보용.*  
  * ***\[Slot 5\] 은신 (Cloak):** 특정 반경 밖에서는 감지 불가 (공격 시 해제). 쿨타임 4턴.*

### **4.3. 대원 개인 성장 (Level Up)**

*전투에 참여하여 생존한 대원은 경험치를 얻고 계급이 상승한다.*

* ***보상:** 전투 능력치의 직접적인 강화. **(사망 시 영구 소실됨 → 상실감 유도)**.*  
  * ***스킬 해금:** 병과별 스킬 트리(공격형 vs 전술형)에서 스킬 선택 및 해금.*  
  * ***스탯 상승:** HP, 명중률(Aim), 치명타율 등 핵심 전투력 증가.*

### **4.4. 기술 연구 (Global Research)**

*기지에서 획득한 자원(데이터)을 소모하여 진행하는 전체 업그레이드.*

* ***보상:** 기반 시설 및 인프라 해금. **(대원의 죽음과 무관하게 유지됨)**.*  
  * ***장비 티어 해금:** 상점에서 상위 등급 장비 및 탄약 구매 권한 개방.*  
  * ***소모품 레시피:** 신규 수류탄, 회복 키트 레시피 해금.*  
  * ***기초 능력 보정:** 아군 전체 시야 거리 증가, 회복 속도 증가 등 보조적 효과.*  
  * 

## **5.0. 전술 환경 및 레벨 디자인 (Tactical Environment) \- *전면 수정***

전투는 **3D 공간의 그리드(Grid)** 위에서 진행되며, **시야, 고저차, 엄폐, 각도**가 상호작용하여 액티브 게이지의 난이도를 결정한다.

### **5.1. 시야 및 투사체 경로 (Vision & Path)**

| 항목 | 상세 규칙 및 기술 사양 |
| :---- | :---- |
| **360도 시야**  | **모든 유닛은 전방향을 감시하며, 별도의 사각지대는 존재하지 않습니다.** |
| **차폐 및 투과**  | **• 벽(Wall) 및 천장(Ceiling): 시야를 완전히 차단합니다. • 창문(Window): 시야를 전혀 가리지 않는 완전 투과(0.0) 방식으로 처리하며, 창문을 통과하는 사격에도 별도의 명중 패널티는 적용하지 않습니다.** |
| **미식별 타겟 대응**  | **시야가 확보되지 않은 안개 지역이라도 특정 타일(Grid Cell)을 지정하여 광역 공격을 시도할 수 있습니다. 공격에 적중하더라도 적의 위치는 드러나지 않고 은폐 상태를 유지합니다.** |
| **성능 최적화**  | **야 업데이트 트리거: ①유닛 이동 시(타일 단위), ②턴 시작 및 종료 시, ③폭발 등으로 인한 구조물 파괴(벽 제거) 이벤트 발생 시 즉시 해당 구역의 시야를 재계산함.** |
| **레이캐스트 사양 📏** | **3D 그리드 내 정확한 판정을 위해 시야 레이캐스트는 지면으로부터 2.0m 높이에서 시작하도록 고정합니다.** |
| **고지대 사각지대(Dead Zone)** | **유닛이 벼랑 끝(Edge) 타일에 인접하지 않은 상태로 아래층을 볼 때, 일정 각도 이상의 사각지대에 있는 적은 감지할 수 없음. 즉, 아래층 적을 사격하려면 반드시 벽이나 낭떠러지 경계 타일로 이동해야 함.** |

### **5.2. 지형 속성 및 고저차 (Terrain Properties)**

타일은 높이(Level)와 **천장(Ceiling)** 속성을 가지며, 이는 투척 및 사격 경로에 영향을 준다.

0: 0층, 1: 1층... (2.5m 단위)

#### **(1) 층간 분리 (Layer Separation)**

* **이동 불가:** 든 수직 단차 이동 로직 삭제. **'순간이동(Teleport)'** 메커니즘으로 대체. 노드 간 직접 연결로만 이동.  
* **물리적 분리:** 모든 층은 물리적으로 완벽히 분리된 평면으로 취급된다.

#### **(2) 천장 유무 (Ceiling Property)**

* **이동과 무관:** 층간 이동이 '순간이동' 방식으로 변경됨에 따라, 천장은 더 이상 유닛의 물리적 이동을 막는 요소가 아니다.  
* **전술적 차단:** 대신 천장은 **'시야(Vision)'와 '투사체(Projectile)'를 물리적으로 차단**하는 역할을 수행한다.  
  * **실내 (Indoor):** 천장이 있어 곡사 무기(수류탄 등) 사용이 불가능하며, 고지대에서의 사격 이점을 받을 수 없다.  
  * **실외 (Outdoor):** 천장이 없어 곡사 투척 및 고지대 낙차 사격이 가능하다.

#### **(3) 구조적 지지 시스템 (Structural Integrity) :**

* **지지체(Anchor):** 지면(Level 0)과 모든 기둥(Pillar)은 지지력의 원천이 된다.  
* **지지력(Support Value):** 기둥/지면에서 시작하여 인접 타일로 전파될 때마다 수치가 1씩 감소한다.  
* **붕괴 조건:** 지지력이 n 이하가 된 타일은 물리적 지지 불능 상태로 간주하여 즉시 파괴된다.  
* **전파 공식** : Stile=max(Sneighbors)-1 (단, 기둥/지면은 S \= 5\)  
* **계산 시점:** 실시간 계산 삭제. **구조물 파괴/설치 이벤트 발생 시에만** 전체 재계산 수행.

### **5.3. 엄폐 효율 결정 공식 (Combat Formula)**

엄폐물의 방어 효과는 고정값이 아니며, 공격자의 각도와 높이에 의해 실시간으로 **곱연산(Multiplicative)** 처리된다.

**FinalCover \= BaseCoverValue × AngleFactor × HeightFactor** \> 1\. **BaseCoverValue:** 반엄폐(20), 완전엄폐(40).

2\. **AngleFactor:** max(0,Vcover ᐧ VAttack). (벡터 내적값 사용)

3\. **HeightFactor:** max(0.8,1.0 \- (ΔH ×0.05) (층수 차이당 5% 감소, 최대 20%)

#### **(1) 각도 계수 (Angle Factor) \- *벡터 내적(Dot Product) 사용* 인위적인 구간 나누기 없이, \*\*벡터 내적값(Cosine)\*\*을 그대로 사용하여 각도가 벌어질수록 엄폐 효율이 자연스럽게 감소한다.**

* **공식:**  
  **AngleFactor \= max(0, V\_Cover · V\_Attack)**

	**V\_Cover : 엄폐물이 바라보는 정면 벡터 (Normalized)**

	**V\_Attack : 타겟에서 공격자를 바라보는 방향 벡터 (Normalized)**

* **적용 예시:**  
  * **정면 (0°): 계수 1.0 (효율 100%)**  
  * **45°: 계수 0.7 (효율 70%)**  
  * **60°: 계수 0.5 (효율 50%)**  
  * **측면/후방 (90° 이상): 계수 0.0 (엄폐 무시)**

#### **(2) 높이 계수 (Height Factor)**

공격자가 타겟보다 높은 곳에 위치할 경우 엄폐 효율을 깎는다.

* **기본 로직:** 층수 차이당 5% 감소" 로직 유지. 단, "실제 높이(2.5m \* 층수)가 아닌 논리적 층수(ΔH)를 기준으로 계산함  
* **예외 (Indoor Exception):** 타겟이 \*\*\[실내\]\*\*에 있고 **\[완전 엄폐\]** 중이라면, 천장에 의해 사격각이 제한되므로 **높이 계수는 1.0(페널티 없음)으로 고정**된다.

#### **(3) 최종 명중률 산출**

* HitChance \= AttackerAccuracy \- FinalCover  
* 엄폐율은 0 미만으로 떨어지지 않으므로(Clamp), 명중률이 비정상적으로 상승하는 현상은 방지된다.


#### **(5) 낙하 데미지 공식 (Fall Damage) :**

* **원칙:** 고정값(Absolute Value) 기반 데미지를 적용한다.  
* **공식:** Dfall= max(0, (ΔH-1) \* 10  
* **설명:** 1층 높이(ΔH=1) 추락 시 데미지 0, 2층 높이 추락 시 데미지 10, 3층 높이 추락 시 데미지 20을 부여한다.

  ### **5.4. 액티브 게이지 시각화 (Active Gauge Visualization)**

최종 산출된 명중률을 기반으로 게이지 바의 영역을 생성한다.

* **녹색 영역 (Hit Zone):** 최종 명중률(HitChance)과 1:1 비례.  
* **적색 영역 (Critical Zone):** HitChance의 \*\*n%\*\*로 설정.  
  * *의도:* 좋은 위치(측면, 고지대)를 잡아 명중률을 높이면, **치명타 확률(영역)도 함께 넓어져** 확실한 보상을 제공한다.

  ### **5.5. 특수 지형지물 (Special Objects)**

* **창문 (Window):**  
  * **시야:** 투명하게 처리되어 시야를 차단하지 않음.  
  * **엄폐:** 부분 엄폐 효과 제공.  
  * **투척:** 투사체가 통과 가능함.  
* **문 (Auto-Door):**  
  * 항상 열린 상태. 시야 차단 데이터 제외  
* **구조적 파괴 (Structural Integrity):**  
  * **맵의 기둥(Pillar)과 벽(Wall)은 내구도(HP)를 가지며 파괴될 수 있다.**  
  * **붕괴(Collapse): 기둥 파괴로 인해 지지력을 상실한 상층 타일은 즉시 파괴되며, 위에 있던 유닛은 낙하 데미지를 입는다.**  
  *  **추락 및 점유: 유닛은 직하단 타일로 추락하며, 아래층이 없으면 연쇄 추락함. 만약 착지 타일에 이미 다른 유닛이 점유 중일 경우, 인접한 빈 타일로 '옆 칸 밀려남' 처리를 수행하여 유닛 겹침을 방지함.**  
* 타일 점유(Tile Occupation):  
  * 유닛, 파괴된 차량 등 일부 오브젝트는 타일 전체를 차지\*하며, 이 타일은 다른 유닛이 통과하거나 멈출 수 없다  
  * 길찾기 시 '이동 불가' 지역으로 취급된다.  
  * 오브젝트의 종류에 따라 '타일 점유' 상태이면서도 이동 비용(Cost)만 높이는 경우도 존재할 수 있다 (예: 낮은 상자).  
* 경계 엄폐(Edge Cover):  
  * 낮은 벽, 난간 등의 엄폐물은 타일과 타일 사이의 '경계'에 위치\*하는 것으로 취급된다.  
  * 이는 이동을 막지 않지만(반엄폐의 경우), 사격 각도에 따라 엄폐 보너스를 제공하는 역할을 한다.  
* **연결 오브젝트 (Connector Object)**  
  * **개요:** 물리적으로 떨어진 두 좌표(Node A ↔ Node B)를 논리적으로 연결하여 이동 경로를 제공하는 오브젝트.  
  * **이동 방식 (Interaction):** 유닛이 진입점(Start Node)에서 상호작용 시, 연결된 도착점(End Node)으로 \*\*즉시 이동(Teleport)\*\*한다..

### **5.6. 맵 데이터 구조 (Map Data Structure)**

맵의 최소 단위인 '그리드 셀(Grid Cell)'은 하나의 덩어리가 아니라, \*\*바닥(Center), 벽(Edge), 기둥(Corner)\*\*으로 구성된 조립 데이터이다.

* **좌표계:** (Col, Row, Level)의 3차원 정수 좌표.  
* **구성 요소 (Cell Composition):** 한 좌표는 다음의 속성을 독립적으로 가진다.  
  1. **센터 (Center):**  
     * **`FloorID`:** 바닥재 (콘크리트, 나무 등).  
       * *예외 처리 (낙사):* 이 값이 `Null`이거나 `None`일 경우, 해당 좌표는 물리적으로 뚫려있는 구멍으로 간주하며, 유닛 진입 시 추락(Fall) 판정이 발생한다.  
     * **`CeilingID`:** 천장재. (상층의 바닥과 별개로 렌더링되거나 공유됨)  
     * **`Object`:** 타일 중앙에 놓인 엄폐물(상자, 드럼통).  
  2. **엣지 (Edge \- North/East/South/West):**  
     * 타일의 가장자리에 위치하는 벽면 데이터.  
     * **유형:** `Wall` (통벽), `Window` (창문), `Door` (문), `None` (개방).  
     * *데이터 최적화:* 인접 타일과 벽을 공유하므로, 저장 시에는 **4방향 고정 배열(Fixed Array) 구조**를 사용하여 인접 타일과 즉각적으로 데이터를 대조한다  
  3. **코너 (Corner):**  
     * 타일의 꼭짓점에 위치하는 기둥(Pillar). 2층 이상 건물을 지을 때 층간의 시각적 연결성을 담당한다.

### **5.7. 모듈형 건축 시스템 (Modular Construction System)**

레벨 디자인은 개별 타일을 배치하는 것이 아니라, 구조화된 모듈을 조립하는 방식을 따른다.

* **조립 규칙 (Assembly Rule):**  
  * **벽(Wall):** 타일의 좌표를 점유하지 않고, 타일과 타일 사이의 '경계선'에 부착된다.  
  * **창문(Window):** 벽과 동일하게 경계선에 부착되나, `IsTraversable` 속성을 가져 이동 및 사격이 가능하다. (넘어가기 연출 필요)  
  * **적층(Stacking):** 2층 건물을 지을 경우, \[1층 벽 \+ 1층 기둥\] 위에 \[2층 벽 \+ 2층 기둥\]을 쌓는 방식으로 구현하여 층별 파괴 및 엄폐 연산을 분리한다.


### **5.8 이동 경로 시각화**

* **범위:** 이동 가능 최대 반경 → **녹색(Green) 오버레이**.  
* **경로(Valid):** 마우스 오버 시 이동 경로 → **파란색(Blue) 라인/타일**.  
* **경로(Invalid):** 이동력 초과 또는 이동 불가 지역(오브젝트/유닛 점유) → **빨간색(Red) 라인/타일**.  
* **복합 경로:** 갈 수 있는 데까지는 파란색, 그 이후부터 빨간색으로 이어지는 **'부분 경로 표시'** 로직 명시.

# **6.0. 기술 아키텍처 (Technical Architecture) \[수정됨\]**

본 프로젝트는 **Unity 3D (URP)** 환경을 기반으로 하며, **Service Locator 패턴**과 **Initializer 패턴**을 결합하여 싱글톤의 폐해(결합도, 순서 문제)를 해결하고, 메모리 생명주기(Lifecycle)를 엄격히 통제한다.

### **6.0.1. 아키텍처 핵심 원칙 (Core Principles)**

1. **서비스 로케이터 (Service Locator):** 모든 매니저 클래스는 싱글톤(Instance) 변수를 가지지 않으며, 오직 ServiceLocator를 통해서만 접근 가능하다.  
2. **하이브리드 등록 (Hybrid Registration):**  
   * **Global Scope:** 매니저가 스스로 등록하는 **자가 등록(Self-Registration)** 방식.  
   * **Scene Scope:** 초기화 순서 보장을 위해 SceneInitializer가 등록하는 **중앙 관리(Centralized Registration)** 방식.  
3. **인터페이스 기반 초기화:** "초기화가 필요한 모든 매니저는 `IInitializable` 인터페이스를 구현하며, 반환 타입은 반드시 \*\*`UniTask`\*\*여야 한다. 모든 초기화는 \*\*비동기(Async/Await)\*\*로 수행되며, 메인 스레드 블로킹(`WaitForCompletion`)을 엄격히 금지한다."  
4. "**1단계(Registration):** `Awake()`에서는 오직 `ServiceLocator.Register(this)`와 자기 자신의 변수 할당만 수행한다. 타 매니저 참조 금지.  
    **2단계(Injection):** 타 매니저 참조 및 리소스 로드는 `Initialize(settings)` 단계에서 수행하여 참조 무결성을 보장한다."  
5. "초기화 도중 치명적인 예외(Exception) 발생 시, 즉시 부팅 절차를 중단하고 에러 로그를 출력한 뒤 애플리케이션을 종료하거나 에러 상태(State)로 전이한다."

---

## **6.1. 개발 환경 및 기반 기술 (Development Stack)**

| 구분 | 기술 스택 / 버전 | 선정 이유 및 비고 |
| :---- | :---- | :---- |
| **엔진** | **Unity 2022.3.62f1 (LTS)** | 장기 지원 버전(LTS)을 사용하여 개발 도중 엔진 버그로 인한 리스크 최소화. |
| **렌더링** | **URP** (Universal Render Pipeline) | 로우 폴리 그래픽에 최적화된 성능. Shader Graph를 통한 캐릭터 실루엣(X-Ray), 포스트 프로세싱(Bloom) 구현 용이. |
| **입력** | **New Input System** | 키보드/마우스 및 게임패드 동시 지원. Action Map(Menu, Gameplay, QTE) 분리 용이. |
| **비동기** | **UniTask** | 코루틴(Coroutine) 대비 가독성이 높고 오버헤드가 적은 async/await 패턴 사용. "Unity의 Native Coroutine 및 Addressables의 동기 함수(`WaitForCompletion`) 사용을 금지하고, 모든 비동기 로직을 UniTask로 통일." |
| **리소스** | **Addressables** | 씬 전환 시 메모리 누수를 방지하고, 리소스의 비동기 로드/해제 관리. |
| **데이터** | **ScriptableObject (SO)** | 기획 데이터(밸런스, 맵 정보)와 로직의 분리. JSON 직렬화 연동. |

---

## **6.2. 시스템 계층 구조 (System Hierarchy) \[수정됨\]**

매니저의 생명주기와 등록 주체에 따라 \*\*Global(App)\*\*과 **Scene(Session)** 두 가지 스코프로 명확히 구분한다.

### **(1) Global Scope (App Lifetime)**

* **생명주기:** 앱 실행 시 AppInitializer에 의해 생성 \~ 앱 종료 시까지 유지 (DontDestroyOnLoad).  
* **등록 방식:** **자가 등록 (Self-Registration)**. Awake()에서 ServiceLocator.Register(this) 호출.  
* "단, `AppInitializer`는 매니저를 **생성(Instantiate)만** 하며, 등록 코드를 포함하지 않는다(의존성 제거)."  
* **초기화 주체:** AppInitializer (Addressables 로드 및 생성 담당).

| 매니저 이름 | 핵심 역할 | 주요 책임 및 기능 |
| :---- | :---- | :---- |
| **ServiceLocator** | **연결** | 모든 매니저의 등록/해제 및 접근점 제공 (싱글톤 대체). |
| **AppInitializer** | **시동** | "앱의 진입점(Entry Point). `AppConfig` 로드 및 Global 매니저 생성(Instantiate)을 담당한다. **\[개발 편의성\]:** `BootScene`이 아닌 일반 씬에서 실행 시, 자동으로 Global 환경을 구축(Bootstrap)하여 개발 속도를 저하시키지 않도록 한다." 단, 자동 부트스트랩의 호출(Trigger)은 SceneInitializer가 수행한다 |
| **GameManager** | **총괄** | 게임의 최상위 상태(Main Menu ↔ InGame) 관리. |
| **DataManager** | **DB** | 게임 내 모든 정적 데이터(SO) 및 세이브 데이터 로드/캐싱. |
| **InputManager** | **입력** | 하드웨어 입력을 게임 Action으로 변환 및 레이어(UI/Game) 제어. |
| **GlobalSettingsSO** | **설정** | 해상도, 사운드 볼륨 등 전역 설정 데이터 컨테이너. |

### **(2) Scene Scope (Session Lifetime)**

* **생명주기:** 전투 씬(InGame) 로드 시 생성 \~ 씬 언로드 시 파괴.  
* **등록 방식:** **중앙 관리 (Centralized Registration)**. **Awake() 사용 금지.**  
* **초기화 주체:** SceneInitializer.

| 계층 (Layer) | 매니저 이름 | 주요 책임 |
| :---- | :---- | :---- |
| **Initializer** | **SceneInitializer** | •"씬 내 매니저의 생성(RegisterOrSpawn) 후, `Start()` 단계에서 \*\*비동기 루프(Async Loop)\*\*를 통해 순차적으로 `Initialize()`를 호출한다. 하나라도 실패 시 게임 진입을 차단한다." • 게임 종료(OnDestroy) 시 등록의 역순으로 안전하게 해제. |
| **State Machine** | **SessionManager** | • 전투의 흐름(FSM) 관리 (Boot → Setup → TurnWaiting → UnitTurn...). • IInitializable 구현 및 상태 전이 제어. |
| **System** | **TurnManager** | • 유닛의 TS(Turn Speed) 계산 및 턴 큐(Queue) 관리. |
|  | **MapManager** | • 맵 생성(WFC/Module), NavMesh 베이크, 엄폐물 데이터 관리. |
| **Combat** | **CombatManager** | • 공격/피격 판정 공식 계산 및 데미지 적용. |
|  | **UnitManager** | • 유닛 스폰, 사망 처리, 리스트 관리. |
| **Visual / UI** | **CameraManager** | • 시점 제어 및 액션 캠 연출. |
|  | **TargetUIManager** | • 타겟 머리 위 UI(HP바, 명중률) 표시 및 풀링. |
|  | **DamageTextMgr** | • 데미지 플로팅 텍스트 연출. |

### **(3) Scene Scope (Non-Battle)**

* 기지(Base) 및 월드맵(WorldMap) 씬 전용 매니저.

| 씬 | 매니저 이름 | 주요 책임 및 기능 |
| :---- | :---- | :---- |
| **Base** | **BaseManager** | • 기지 내 UI 메뉴(연구, 병영, 정비) 네비게이션 처리. • SquadManager와 연동하여 대원 치료/훈련 로직 수행. |
| **World** | **MissionManager** | • 랜덤 미션 생성 및 지역별 보상 데이터 관리. • 선택된 미션 정보를 Battle 씬으로 전달(MapDataSO). |

### **6.3. 핵심 시스템 구현 로직 (Core Implementation Logic)**

#### **(1) 물리 레이어 구성 (Physics Layers)**

Raycast 판정의 정확도를 위해 레이어를 명확히 구분한다.

| 레이어 이름 | 용도 | Raycast 활용 예시 |
| :---- | :---- | :---- |
| **Ground** | 바닥/지형 | 마우스 클릭 이동 지점 판별. |
| **Wall** | 높은 벽 | 시야(Vision) 차단, 직사 화기 차단. |
| **Cover** | 낮은 엄폐물 | 엄폐 판정, 시야는 통과(부분 엄폐)하나 이동은 차단. |
| **Unit** | 캐릭터 | 공격 타겟팅 판별. |
| **Ceiling** | 지붕/천장 | 실내 판정, 곡사 화기(투척) 차단. |

#### 

#### **(2) 전투 공식 파이프라인 (Combat Formula Pipeline)**

공격 시도 시 다음 순서로 연산하여 최종 결과를 도출한다.

1. **각도 계수 (FAngle) 산출 :**  
   * 벡터 내적: D \= **VCover ᐧ VAttack**  
   * **FAngle \= Mathf.Max(0,D)**

**2\. 높이 계수(FHeight) 산출 :**

* 층수차이 : ΔH \= Attacker.Layer \- Target.Layer  
* 실내 예외 처리 : 타겟이 Indoor이고 엄폐물이 High Cover면 ΔH \= 0 으로 강제.  
*  FHeight \= max(0.80,1.0 \- (ΔH x 0.05))

**3\. 최종 엄폐율(RCover) 산출 :** 

* **RCover \= BaseCover X FAngle X FHeight**

**4\. 최종 명중률(Phit) 산출 :** 

* **PHit \= Attacker.Accuracy \- RCover**

#### **(3) 시체 루팅 시스템 (Looting Logic)**

* **생성:** UnitManager가 적 사망 확인 → LootManager에게 사망 위치 전달 → LootManager가 해당 타일에 Corpse 프리팹 생성.  
* **상호작용:**  
  1. 플레이어 유닛이 시체 인접 타일 도착.  
  2. InteractionManager가 '조사하기(Search)' 액션 활성화.  
  3. 실행 시 ActionCount  소모 → LootManager가 LootTable을 굴려 아이템 생성 → InventoryManager로 즉시 지급.  
  4. 시체 오브젝트는 '빈 시체' 상태로 변경 (재조사 불가).  
  5. 전투 중 유닛이 시체를 조사하거나 상자를 열면 아이템이 인벤토리에 즉시 들어오는 대신, \*\*'획득 예정 리스트(Pending Loot)'\*\*에 누적  
  6. 전투 승리/퇴각 후 결과 화면에서 해당 리스트가 세이브 데이터의 공용 창고(`InventoryManager`)로 일괄 전송

#### **(4) 이동 및 길찾기 (Movement & Pathfinding)**

* **기술:** A\\ 알고리즘을 사용한 순수 그리드 기반 길찾기.  
* **비용 계산: 길찾기는 각 타일의 '이동 비용(Cost)'을 고려하여 최단 경로가 아닌 '최소 비용' 경로를 탐색한다.**  
* 이동 제약 조건:  길찾기 시 다음 조건들을 모두 만족해야 한다.  
  1\. 이웃 타일이 맵 범위 안에 있는가?  
  2\. 이웃 타일이 다른 오브젝트에 의해 '점유'되어 이동 불가능 상태가 아닌가?  
  3\. 현재 타일과 이웃 타일 사이의 '경계'가 완전 엄폐(Full Cover)로 막혀있지 않은가?  
  4\. 이동 제약 조건:  
* 기본적으로 동일 높이(Level) 내에서만 인접 타일로 이동 가능하다.  
* **연결 이동 (Teleport):** 현재 타일이 \*\*'연결 오브젝트(Connector)'\*\*의 노드일 경우, 물리적 거리를 무시하고 연결된 목적지 타일로 이동 경로를 확장한다.

#### **(5) 유닛-컨트롤러 아키텍처 (Unit-Controller Architecture)**

본 프로젝트는 유닛의 데이터/상태와 제어 로직을 명확히 분리하는 컨트롤러 패턴을 따른다.

* \`Unit\` (\`UnitStatus.cs\`의 역할):  
  * 전장에 존재하는 모든 개체(아군, 적군)를 의미한다.  
  * 자신의 모든 상태(HP, TS, 위치, 보유 어빌리티 등)와 기본 데이터(UnitDataSO)를 소유한다.  
  * 외부의 '명령'에 따라 자신의 상태를 변경하거나 행동(이동, 피격 등)을 실행할 뿐, 스스로 행동을 '결정'하지  않는다  
* \`Controller\` (\`PlayerController.cs\`, \`AIController.cs\`의 역할):  
  * Unit을 소유(Possess)하여 조종하는 '두뇌'에 해당한다.  
  * TurnManager로부터 자신의 유닛이 턴을 획득했음을 통지받으면 활성화된다.  
  * \`PlayerController\`는 사용자의 입력을 받아 Unit에게 명령을 내린다.  
  * \`AIController\`는 자체적인 AI 로직에 따라 판단하여 Unit에게 명령을 내린다.


  


### **6.4. 데이터 구조 (Data Architecture)**

모든 기획 데이터는 수정이 용이한 ScriptableObject로 구조화한다.

| 데이터 타입 (SO) | 포함 필드 (Fields) | 용도 |
| :---- | :---- | :---- |
| **UnitDataSO** | 이름, 병과, 모델 프리팹, BaseHP, Mobility, Accuracy, Evasion | 아군/적군 유닛의 기본 스펙 정의. |
| **WeaponDataSO** | 이름, 사거리, 데미지, **ActionModule (참조)** | 무기별 스펙 및 공격 방식 정의. |
| **ActionModuleSO** | 미니게임 타입(Hold, Timing, Focus), 난이도 계수, UI 프리팹 | 무기마다 다른 액티브 게이지 로직을 모듈화. |
| **MapDataSO** | 맵 프리팹(Terrain), 적 스폰 포인트 리스트, 등장 적 종류(Pool) | 미션별 맵 구성 및 적 배치 정보. |
| **LootTableSO** | 아이템 리스트, 드랍 확률(Weight) | 적 사망 시 드랍할 아이템 테이블. |
| **ConsumableDataSO** | 이름, 효과 타입(Damage/Heal/Buff/Scan), 효과 수치, 범위, 구매 가격, 환불 가격 | 소모품 스펙 정의 |

### **6.5. 코딩 컨벤션 (Coding Conventions)**

Enum 관리 원칙: '1 Enum, 1 File'

* 모든 열거형(Enum)은 각자의 의미를 가장 잘 나타내는 이름의 .cs 파일에 단독으로 정의한다. (예: CoverType.cs, UnitCondition.cs, PlayerActionState.cs)  
* 목적:\* 프로젝트의 규모가 커지더라도 코드의 명확성과 유지보수성을 유지하고, 여러 개발자가 동시에 작업할 때 발생할 수 있는 병합 충돌을 원천적으로 방지하기 위함이다. 이는 프로젝트 전반의 '관심사 분리' 설계 원칙과 일관성을 유지한다.  
* "모든 비동기 메서드에는 접미사 `Async`를 붙이지 않더라도 반환 타입으로 구분한다(UniTask). `void` 반환 비동기 메서드(`async void`)는 이벤트 핸들러를 제외하고 금지하며, `async UniTaskVoid`를 사용한다."

# 

# **7.0. UI/UX 시스템 (User Interface & Experience)**

### **7.1. 디자인 원칙 (Design Principles)**

* **분산형 인터페이스 (Decentralized UI):** *XCOM 2* 스타일을 차용하여, 정보의 성격에 따라 화면 좌/우/중앙으로 UI를 분산 배치하여 전장(Center Screen)의 시야를 확보한다.  
* **상황 반응형 연출 (Context-Sensitive):** 평소에는 전술 정보를 보여주다가, 액션(공격/방어) 순간에는 UI를 숨기고 QTE 패널과 카메라 연출에 집중하게 하여 몰입감을 높인다.  
* **직관적 피드백:** 복잡한 수치 계산(엄폐, 각도) 결과는 \*\*'액티브 게이지의 영역 크기'\*\*와 \*\*'명중률 %'\*\*로 단순화하여 표시한다.

---

### **7.2. 전투 화면 레이아웃 (Battle HUD)**

| 위치 | 구성 요소 (Component) | 표시 정보 및 기능 |
| :---- | :---- | :---- |
| **좌측 하단**  (Unit Status) | **유닛 정보 패널** | • **초상화:** 현재 턴 유닛의 얼굴. • **HP 바:** 현재 체력 / 최대 체력 (수치 포함). • **상태 아이콘:** 버프/디버프 (마우스 오버 시 툴팁). |
| **우측 하단**  (Weapon Info) | **무기 패널** | • **무기 이미지:** 현재 장착 중인 주무기. • **기본 스펙:** 공격력 범위 (ex: 4-6), 치명타 확률. |
| **하단 중앙**  (Skill Deck) | **스킬 바 및 \[소모품 슬롯 (1\~2칸)\]** | • **아이콘 리스트:** 기본 사격, 경계(Overwatch), 직업 스킬. • **단축키:** 키보드 숫자키(1\~9) 또는 패드 십자키/범퍼 연동. |
| **타겟 상단**  (World Space) | **타겟 정보** | • **HP 바:** 적의 남은 체력. • **방어 상태:** 엄폐 아이콘 (방패 모양 \- 깨짐/반/완전). • **명중률:** 최종 계산된 Hit Chance (%). |
| **화면 중앙**  (Overlay) | **QTE 패널** | • **공격 시:** 무기별 액티브 게이지 (Attack Phase에만 팝업). • **방어 시:** 위기 감지 경고 및 커맨드 입력창 (Defense Phase에만 팝업). |
| **공격 활성화 유닛 주변**  | **공격 사거리 표시 원** | World Distance(반경, Radius)로 계산하며, 이를 시각적으로 보여주는 **Decal/Gizmo** 시스템이 필요함 |

---

### **7.3. 전투 조작 흐름 및 카메라 연출 (Combat Flow)**

**(1) 공격 시퀀스 (Player Attack Sequence)**

1. **유닛 포커스 (Turn Start):**  
   * 현재 턴인 아군 유닛 **A**에게 카메라 포커스 및 조작 권한 부여.  
2. **타겟 지정 (Targeting):**  
   * 플레이어가 사거리 내의 적 유닛 **B**를 클릭 (또는 패드 타겟팅).  
   * 적 **B**의 머리 위에 **\[타겟 정보(명중률, HP)\]** 표시.  
3. **행동 선택 (Select Skill):**  
   * 하단 중앙 \*\*\[스킬 바\]\*\*가 활성화됨 (이전까진 비활성 혹은 숨김).  
   * 마우스 클릭, 숫자키(1\~9), 혹은 패드 조작으로 사용할 스킬 선택.  
   * *선택 시 스킬의 예상 데미지나 효과 범위가 미리보기(Preview) 됨.*  
4. **타겟 선택 및 공격 확정 (2-Step Confirmation):**  
   * (PC/모바일 공통) 공격 스킬 선택 후 적 유닛을 클릭(터치)하면, 공격이 즉시 발동한다.

      **5\. UI 전환 및 QTE 진입 (Enter Action Phase):**

* 공격이 확정되면, 기존 HUD가 사라지거나 흐려지고(Dimmed), 화면 정중앙에 \[무기별 미니게임 패널\] 팝업.  
  * 소모품 사용 시에는 QTE(미니게임) 없이 즉시 발동  
5. **QTE 수행 (Action):**  
   * 플레이어의 피지컬 조작 수행 (Timing / Hold / Focus).  
6. **결과 연출 (Result):**  
   * 액션 뷰(Action View) 진입.  
     1. 공격자와 타겟 사이의 특정 오프셋(`actionViewOffset`) 지점으로 카메라가 즉시 이동하여 박진감 있는 구도를 형성함.  
     2. 타격 시 \*\*임팩트 쉐이크(Impact Shake)\*\*를 호출하여 시각적 타격감을 극대화함  
   * 총구 화염, 탄환 궤적, 타격 이펙트 재생.  
   * **결과 확인:** 피격 모션, HP 감소, 데미지 텍스트(Critical/Miss)가 뜨는 동안 **약 1.0\~1.5초간 카메라 유지**.  
7. **카메라 복귀 (Return):**  
   * 턴이 종료되면 다음 순서 유닛에게로 이동.  
   * 턴이 남아있다면(AP 잔존) 다시 유닛 **A**에게로 복귀.

**(2) 방어 시퀀스 (Active Defense Sequence)**

1. **적 행동 개시:** 적 유닛 **B**가 행동을 시작. 카메라는 **B**를 비춤.  
2. **위기 감지 (Focus & Warning):**  
   * 적 **B**가 아군 **A**를 공격하려는 순간, 카메라가 공격자와 피격자를 한 화면에 담는 액션 뷰 구도로 전환  
   * **0.5초 대기:** 플레이어가 "내가 공격받는구나"를 인지할 시간 부여.  
3. **QTE 판정 및 발동 (Conditional QTE):**  
   * **조건 체크:** 이번 공격이 **\[치명타\]** 혹은 \*\*\[사망(Lethal)\]\*\*에 해당하는가?  
   * **True (위기):** **CalculateSurvivalChance() 확률로 경감 및 즉사 방지 QTE 발동. 성공 시 경감(50%) / HP 1로 생존하며, 실패 시 영구 사망함.**"  
   * QTE 성공 시: **체력 1을 남기고 생존.**  
   * **다수 타겟 발생 시: 무작위(Random) 순서로 순차적(Sequential) QTE 진행.**  
   * **False (일반):** QTE 없이 바로 피격 연출로 진행.  
4. **결과 연출:**  
   * 아군 **A**의 피격/회피 모션 및 HP 변화.  
   * **1.0초 유지:** 플레이어가 피해량을 확인할 수 있도록 대기.  
5. **카메라 복귀:** 다시 행동권을 가진 적 유닛 **B** 혹은 다음 턴 유닛에게로 이동.

---

### **7.4. 액티브 게이지 시각화 (Visual Feedback)**

공격 QTE 패널은 무기 타입에 따라 다른 UI 프리팹을 사용한다.

| 무기 타입 | UI 디자인 컨셉 | 조작 방식 |
| :---- | :---- | :---- |
| **돌격소총** | **수평 게이지 (Horizontal Bar)**  왼쪽에서 오른쪽으로 차오르는 게이지. | **Hold & Release**  버튼을 누르면 게이지가 빠르게 상승 하강 반복, \[성공 영역\]에서 버튼을 뗌. |
| **저격소총** | **스코프 뷰 (Scope Circle)**  화면 중앙 십자선과 흔들리는 조준원. | **Focus Aim**  마우스/스틱으로 흔들리는 원을 중앙에 유지하며 시간 버티기. |
| **샷건/근접** | **원형 링 (Radial Ring)**  시계 방향으로 회전하는 바늘. | **Timing Hit**  바늘이 \[성공 영역\]을 지날 때 버튼 클릭 (리듬게임). |

---

### **7.5. 입력 매핑 (Input Mapping) \- *InputManager 연동***

| 동작 (Action) | PC (Keyboard/Mouse) | Gamepad (Xbox 기준) | 비고 |
| :---- | :---- | :---- | :---- |
| **카메라 이동** | WASD / 마우스 화면 가장자리 | 왼쪽 스틱 (L-Stick) | 모든 카메라 이동 및 회전에는 보간(Lerp/Slerp) 및 Smoothing(기본값 5f)이 적용되어 부드러운 화면 전환을 제공함. |
| **카메라 회전** | 마우스 우클릭 드래그(`mouseRotationSpeed`) 및 키보드 회전 축(`rotationSpeed`) 동시 지원. | 오른쪽 스틱 (R-Stick) | 모든 카메라 이동 및 회전에는 보간(Lerp/Slerp) 및 Smoothing(기본값 5f)이 적용되어 부드러운 화면 전환을 제공함. |
| **커서/타겟팅** | 마우스 포인터 | D-Pad (타겟 순환) |  |
| **확인/선택** | 좌클릭 / Space | A 버튼 |  |
| **취소/뒤로** | 우클릭 / ESC | B 버튼 |  |
| **스킬 선택** | 숫자키 1 \~ 9 | LB / RB (스킬 순환) |  |
| **QTE 조작** | Space (공통) / 마우스 | A 버튼 (공통) / 스틱 | 무기별 상이 |
| **정보 보기** | Alt (토글) | Y 버튼 | 타겟 상세 정보 |

# **8.0. 핵심 데이터 구조 (Core Data Structure)**

게임 내 모든 콘텐츠 데이터는 ScriptableObject로 정의하며, DataManager를 통해 로드 및 참조된다.

### **8.1. UnitDataSO (유닛 기본 정보)**

아군 대원 및 적군 유닛의 공통 스펙.

* **수정사항:** 적군은 방어 등급(DefTier)을 가지지 않으므로 해당 필드를 삭제했습니다.

| 필드명 | 타입 | 설명 |
| :---- | :---- | :---- |
| **UnitID** | string | 유닛 고유 ID |
| **UnitName** | string | UI 표시 이름 |
| **ClassType** | Enum | 병과 (Assault, Sniper, Scout, Enemy) |
| **CanMoveAfterAttack** | bool | 공격 후 이동 가능 여부 (병과별 특성) |
| **ModelPrefab** | AssetReference | 3D 모델 프리팹 |
| **BaseStats** | Struct | 기본 능력치 묶음 |
| └ MaxHP | int | 최대 체력 |
| └ Mobility | int | 이동 거리 (타일 수) |
| └ Agility | int | 민첩성 (턴 순서 TS 계산용) |
| └ Aim | int | 기본 명중률 |
| └ Evasion | int | 기본 회피율 |
| └ CritChance | float | 기본 치명타 확률 |
| DefaultLoadout | Struct | 기본 장비 세팅 |
| └ `MainWeapon` | WeaponDataSO | 기본 주무기  |
| └ `BodyArmor` | ArmorDataSO | 기본 방어구 (없으면 T0) |
| └ `StartingAmmo` | ConsumableDataSO | **기본 탄약** (공격 등급 결정, 적군은 무한 사용) |
| └ **`ExtraItems`** | List\<ConsumableDataSO\> | **추가 소지품 (수류탄, 회복약 등). 적군은 이를 1회성으로 사용함.** |
| **AI\_Behavior** | SO | (적군용) AI 행동 패턴 트리 참조 |

### **8.2. WeaponDataSO (무기 데이터)**

무기의 스펙과 액션 기믹 정의. (공용 탄약 소모)

| 필드명 | 타입 | 설명 |
| :---- | :---- | :---- |
| WeaponID | string | 무기 ID |
| WeaponType | Enum | 무기군 (Rifle, Sniper, Shotgun, Melee) |
| Damage | MinMaxInt | 기본 피해량 범위 (ex: 4 \~ 6\) |
| Range | int | 사거리 (타일 수) |
| DmgFalloff | AnimationCurve | 거리별 데미지 배율 그래프 |
| ActionModule | ActionModuleSO | 공격 시 실행될 QTE 로직 및 UI 프리팹 참조 |
| CritBonus | float | 치명타 추가 데미지 배율 |
| VFX\_Ref | AssetReference | 발사/타격 이펙트 |
| AccuracyCurve | AnimationCurve | 거리(X)에 따른 명중 보정값(Y) 그래프. |
| DamageFalloffCurve | AnimationCurve | 거리(X)에 따른 데미지 배율(Y: 0\~1.5) 그래프. |
| AllowedClass | Enum | 이 무기를 장착 가능한 병과(Assault, Sniper, Scout). |

### **8.3. ArmorDataSO (방어구 데이터)**

아군 대원 전용 방어구.

* **수정사항:** MobilityPenalty로 명칭 변경. 입력된 수치만큼 이동력이 **감소**함 (과학적 고증 반영).

| 필드명 | 타입 | 설명 |
| :---- | :---- | :---- |
| **ArmorID** | string | 방어구 ID |
| **DefenseTier** | int | 방어 등급 (T1\~T5) |
| **MobilityPenalty** | int | **이동력 감소량**. (예: 1 입력 시 이동력 \-1) |

### **8.4. ConsumableDataSO (소모품 및 탄약 데이터)**

전투 중 사용하는 아이템 및 탄약. 캠프 구매/환불 데이터 포함.

* **수정사항:** Ammo 타입 추가 및 AttackTier 필드 생성. ZoneDamage 타입 및 Duration 필드 추가.  
* 인벤토리 및 아이템 루팅 : 인벤토리는 공용 인벤토리로 해당 인벤 토리에는 수류탄, 회복약, 

| 필드명 | 타입 | 설명 |
| :---- | :---- | :---- |
| **ItemID** | string | 아이템 ID |
| **EffectType** | Enum | 효과 유형 정의 |
| └ *Types:* | *List* | Ammo (탄약), Damage (수류탄), ZoneDamage (지역점령 화염), Scan (정찰), Heal (치료), ResetAttack (탄창), ResetMove (음료) |
| **AttackTier** | int | **(Ammo 전용)** 공격 등급 (T1\~T5). 공방 공식의 핵심 변수. |
| **EffectValue** | float | 효과 수치 (데미지량, 회복량 등) |
| **Duration** | int | **(ZoneDamage 전용)** 효과 지속 턴 수 (0이면 즉시) |
| **EffectRange** | int | 투척 사거리 |
| **AreaRadius** | int | 효과 적용 반경 (1 \= 단일, 3 \= 3x3 범위) |
| **PurchaseCost** | int | 구매 가격 |
| **RefundCost** | int | 환불 가격 |
| **VFX\_Ref** | AssetReference | 사용/폭발 이펙트 |

### 

### 

### 

### 

### **8.5. ActionModuleSO (액션 기믹 모듈)**

무기별 미니게임 로직.

| 필드명 | 타입 | 설명 |
| :---- | :---- | :---- |
| **ModuleName** | string | 모듈 이름 |
| **InputType** | Enum | 입력 방식 (Timing, Hold, Focus) |
| **GaugePrefab** | GameObject | UI 프리팹 |
| **DifficultyParams** | float\[\] | 난이도 변수 |
| **TimeLimit** | float | 입력 제한 시간 |

### **8.6. AbilityDataSO (어빌리티 데이터)**

병과 스킬 정의.

| 필드명 | 타입 | 설명 |
| :---- | :---- | :---- |
| **AbilityID** | string | 어빌리티 고유 ID |
| **AbilityName** | string | UI 표시 이름 |
| **AbilityIcon** | AssetReference | UI에 표시될 아이콘 |
| **AbilityType** | Enum | 액티브(스킬), 패시브(특성) 등 구분 |
| **TargetType** | Enum | 자신, 적 단일, 범위, 경로 등 타겟팅 방식 |
| **SlotPrefence** | Enum | 선호 슬롯 (Primary, Special, Grenade, Item 등) |
| **Cooldown** | int | 재사용 대기시간 (턴 단위)  |
| **EndsTurn** | bool | 사용 시 턴 강제 종료 여부 |
| **Effects** | List\<EffectSO\> | 데미지, 버프, 디버프 등 실제 효과 목록 |
| **Costs** | List\<ResourceCost\> | 어빌리티 사용 시 소모되는 자원 목록. |

### 

\`ResourceCost\` 구조체 정의

| ResourceType |  Enu | 소모될 자원의 종류 (Ammo, HP, Energy 등) |
| :---- | :---- | :---- |
| **Amount**   | int  | 소모량 |

### 

### **8.7. MapDataSO (맵/미션 데이터)**

| 필드명 | 타입 | 설명 |
| :---- | :---- | :---- |
| **MapID** | string | 맵 ID |
| **MapPrefab** | AssetReference | 3D 지형 프리팹 |
| **GridSize** | Vector2Int | 맵 크기 |
| **SpawnPoints** | List\<Vector3\> | 아군/적군 시작 좌표 |
| **EnemyPool** | List\<UnitDataSO\> | 등장 적 유닛 리스트 |
| **LootTable** | LootTableSO | 맵 드랍 테이블 |

### **8.8. MapEditorSettingsSO (맵 에디터 공통 설정)**

| 필드명 | 타입 | 설명 |
| :---- | :---- | :---- |
| **solidWallPrefab** | GameObject | 맵의 기본 벽체 프리팹 |
| **windowPrefab** | GameObject | 창문 모듈 프리팹 |
| **doorPrefab** | GameObject | 문/출입구 모듈 프리팹 |
| **pillarPrefab** | GameObject | 코너 기둥 구조물 프리팹 |

# **9.0. 핵심 밸런싱 공식 (Core Balancing Formulas)**

본 장에서는 8.0장의 데이터(SO)들이 실제 게임 내에서 상호작용하여 결과를 도출하는 수학적 규칙을 정의한다.

### **9.1. 데이터 처리 원칙 (Data Processing)**

* **내부 연산 (Logic):** 모든 데미지와 확률 계산은 float 형태로 처리하며, **소수점 셋째 자리에서 반올림하여 둘째 자리까지** 유지한다.  
  * *예:* 5.678 → 5.68  
* **UI 표시 (Display):** 플레이어에게 보여주는 최종 데미지 및 HP 수치는 \*\*소수점을 버리고 정수(자연수)\*\*로만 표기한다.  
  * *예:* 내부 5.68→ UI 표시 5

### **9.2. 데미지 산출 파이프라인 (Damage Pipeline)**

공격 적중 시, 최종 데미지는 다음 단계의 연산을 거쳐 결정된다.

FinalDamage \= BaseDmg × fdmg (d)  × Efficiency × CritMod

fdmg(d) : 무기별 damageFolloffCurve에서 산출된 배율

* **결과 처리:** 최종값은 **\[5, 99\]** 범위로 클램프(Clamp)함.

| 단계 | 변수명 | 설명 및 공식 |
| :---- | :---- | :---- |
| **1\. 기본 피해** | BaseDmg | WeaponDataSO의 Min\~Max 범위 내 랜덤 추출. |
| **2\. 거리 보정** | RangeMod | DmgFalloff.Evaluate(Distance) (0.00 \~ 1.00). |
| **3\. 공방 효율** | Efficiency | 탄약 공격 등급과 방어 등급 차이에 따른 보정 (9.3항). |
| **4\. 치명타** | CritMod | **기본 1.5배**. (추후 스킬/아이템에 의해 합연산으로 증가 가능). |
| **5\. 최종 처리** | Result | 계산 결과는 소수점 둘째 자리까지 유지하되, UI에는 정수로 표시. |

### **9.3. 공방 효율 공식 (Tier Efficiency)**

\*\*"탄약(공격) 등급과 방어구 등급의 격차(Gap)"\*\*에 따라 데미지 효율이 결정된다.

* **변수 정의:**  
  * **공격 등급 (**TAtk**):** ConsumableDataSO (Ammo)의 AttackTier.  
  * **방어 등급 (**TDef**):** 착용 방어구의 DefenseTier (적군은 UnitDataSO의 BaseDefTier).  
  * **격차 (**Gap**):** TDef-TAtk  
* 공식:  
  Efficiency \= 2/(max(0,Gap)+2)

### **9.4. 명중 및 액티브 게이지 공식 (Hit & QTE Mechanics)**

최종 산출된 명중률(PHit)을 기반으로 UI 게이지 바(Bar)를 생성하고, 플레이어의 입력 타이밍에 따라 최종 판정을 내린다.

#### **(1) 게이지 영역 구성 (Gauge Zones)**

게이지 바는 4가지 색상 영역으로 구분되며, 각 영역에 히트(Hit)했을 때의 결과는 다음과 같다.

| 색상 (Color) | 판정 (Result) | 데미지 보정 (Multiplier) | 설명 |
| :---: | :---: | :---: | :---: |
| **검정 (Black)** | **빗맞음 (Miss)** | **0% (데미지 없음)** | 명중 실패. 탄환이 빗나감. |
| **녹색 (Green)** | **스치듯 명중 (Graze)** | **75% (데미지 감소)** | 명중했으나 급소를 피함. 일반 데미지의 75%만 적용. |
| **노랑 (Yellow)** | **정확한 명중 (Hit)** | **100% (기본 데미지)** | 의도한 대로 정확히 명중함. |
| **빨강 (Red)** | **치명타 (Critical)** | **150% \+ @** | 급소 적중. 치명타 보너스 적용. |

#### **(2) 영역 비율 산출 공식**

플레이어의 \*\*스탯(명중률, 치명타율)\*\*은 이 영역들의 \*\*'크기(너비)'\*\*를 결정하는 데 사용된다.

1. **전체 성공 범위 (Success Zone):**  
   * **공식:** TotalWidth \= (Unit.Aim \- CoverPenalty) / 100  
   * 이 범위가 \*\*\[녹색 \+ 노랑 \+ 빨강\]\*\*의 총합이 된다.  
2. **치명타 영역 (Red Zone):**  
   * **공식:** RedWidth \= TotalWidth \* (Unit.CritChance / 100\)  
   * 성공 범위 내에서 치명타 확률만큼의 지분을 차지한다.  
3. **안정권 영역 (Yellow Zone):**  
   * **공식:** YellowWidth \= TotalWidth \* 0.5 (기본값)  
   * 숙련도나 장비에 따라 노란색 영역 비율을 늘려 '녹색(손해)'을 줄일 수 있다.  
4. **손해 영역 (Green Zone):**  
   * **공식:** GreenWidth \= TotalWidth \- (RedWidth \+ YellowWidth)  
   * 명중률은 확보했으나, 완벽하게 조준되지 않은 불안정한 영역.

### **9.5. 이동력 산출 공식 (Mobility Formula)**

FinalMobility \= max(1,Unit.Mobility \- Armor.MobilityPenaly)

### **9.6. 경제 밸런싱 (Economy)**

* **구매가:** `ConsumableDataSO` 데이터 참조.  
* **환불가:**

RefundCost \= \[PurchaseCost × 0.3 \] 소수점 버림

# **10.0. 데이터 기반 어빌리티 및 UI 시스템 (Data-Driven Ability & UI System)**

### **10.1. 아키텍처 목표 및 구현 가이드 (Architectural Goal & Implementation Guide)**

잘못된 구현 (Anti-Pattern): A안  
  이와 같은 방식의 구현을 엄격히 금지한다. 아래 코드는 UI가 게임의 모든 규칙을 알아야 하므로, 신규 콘텐츠 추가 시 UI  
  코드를 직접 수정해야 하는 문제를 야기한다.

    1 // A안: 잘못된 구현의 예시. (UI 코드 내)  
    2 function DrawUI\_Bad(unit) {  
    3     // 규칙 1: 4번 슬롯은 병과에 따라 다르다.  
    4     if (unit.Class \== "Assault") {  
    5         ShowIcon(4, "파편수류탄\_아이콘");  
    6     } else if (unit.Class \== "Sniper") {  
    7         ShowIcon(4, "화염병\_아이콘");  
    8     }  
    9     // ... 신규 병과가 추가될 때마다 이 if문을 계속 수정해야 함 ...  
   10  
   11     // 규칙 2: 5번 슬롯은 레벨에 따라 바뀐다.  
   12     if (unit.Level \< 5\) {  
   13         ShowIcon(5, "일반\_제압사격\_아이콘");  
   14     } else {  
   15         ShowIcon(5, "강화\_제압사격\_아이콘");  
   16     }  
   17     // ... 새로운 레벨업 규칙이 생기면 이 코드를 또 수정해야 함 ...  
   18 }

  \---  
  올바른 구현 (Target Architecture): B안  
  모든 UI 구현은 아래의 설계 사상을 따라야 한다. UI는 '어빌리티 목록'이라는 데이터의 '시각적 표현'일 뿐, 어떠한 게임  
  규칙도 포함해서는 안 된다.

    1 // B안: 올바른 구현의 예시. (UI 코드 내)  
    2 function DrawUI\_Good(unit) {  
    3     // 1\. '진실의 원천'인 현재 유닛의 어빌리티 목록을 가져온다.  
    4     List\<Ability\> abilities \= unit.GetAbilities();  
    5  
    6     // 2\. 목록을 순회하며 각 어빌리티 데이터가 시키는 대로 그린다.  
    7     foreach (Ability ability in abilities) {  
    8         // 이 어빌리티의 아이콘은? \-\> ability.Icon  
    9         // 이 어빌리티의 선호 슬롯은? \-\> ability.PreferredSlot  
   10         ShowIcon(ability.PreferredSlot, ability.Icon);  
   11     }  
   12  
   13     // 신규 병과, 신규 레벨업 스킬, 신규 아이템 스킬이 추가되어도  
   14     // 이 UI 코드는 단 한 줄도 수정할 필요가 없다.  
   15     // 단지 유닛의 GetAbilities() 목록에 데이터가 추가/변경될 뿐이다.  
   16 }

.

### **10.2. 기본 슬롯 레이아웃 및 선호 타입 (Default Slot Layout & Preferred Types)**

 AbilityDataSO가 가지는 SlotPreference의 종류와, 각 타입이 우선적으로 배치될 슬롯 번호의 기준은 아래와 같다.

### 

| 슬롯 | 기능 | 대상 | 비고 |
| :---- | :---- | :---- | :---- |
| **1** | **주무기 사격** | EquippedWeapon | 기본 공격. |
| **2** | **경계 (Overwatch)** | (공통) | 이동하는 적 반응 사격. |
| **3** | **엄폐 (Hunker)** | (공통) | 회피/방어 대폭 상승. 공격 기회 소모. |
| **4** | **투척 무기** | Class Grenade | 병과별 고유 수류탄 (아래 참조). |
| **5** | **특수 기술** | Class Special | 병과별 특수기 (제압, 권총, 은신). |
| **6** | **탄약 선택** | Ammo Selector | 현재 탄약 표시. (▲▼ 키로 인벤토리 탄약 교체) |
| **7** | **소모품** | Inventory Items | 소지한 주사기, 음료, 키트 등 자동 바인딩. |
| **8** | **화면 복귀** |  | **화면 복귀** |
| **9** | **턴 종료** |  | 턴 종료 |

### 

### 

### **10.3. 병과별 기본 어빌리티 목록 (Default Ability List by Class)**

  각 병과는 생성 시 아래의 기본 AbilityDataSO들을 자신의 '어빌리티 목록'에 포함한다.

   \* 돌격병 (Assault):  
       \* \`파편 수류탄\` (SlotPreference: Grenade)  
       \* \`제압 사격\` (SlotPreference: Special)  
   \* 저격병 (Sniper):  
       \* \`화염병\` (SlotPreference: Grenade)  
       \* \`권총 사격\` (SlotPreference: SecondaryWeapon)  
   \* 정찰병 (Scout):  
       \* \`스캔 수류탄\` (SlotPreference: Grenade)  
       \* \`은신\` (SlotPreference: Special)

### 

###   **10.4. UI 레이아웃 규칙 (UI Layout Rules)**

   1\. 슬롯 우선순위 배정: BattleUIManager는 유닛의 '어빌리티 목록'을 가져와, 각 어빌리티의 SlotPreference에 따라 10.2절의 표에 명시된 번호에 우선적으로 아이콘을 배치한다.  
   2\. 유동적 슬롯 채우기: SlotPreference가 없거나, 해당 번호 슬롯이 이미 차 있는 어빌리티들은 2, 3, 6, 7번 등 비어있는 슬롯 중 앞 번호부터 순서대로 채워진다.  
   3\. 가변적 슬롯 개수: 유닛의 어빌리티 개수가 9개 미만일 경우, 사용하지 않는 슬롯은 UI 상에서 비활성화(Grayedout)되거나 숨김 처리한다.

### **10.5. 탄약 시스템 연동 (Ammo System Integration)**

* 탄약은 이 게임의 핵심 자원이므로, 어빌리티 시스템과 아래와 같이 연동된다  
* 탄약 인벤토리: UnitStatus는 유닛이 소지한 탄약의 종류와 수량을 Dictionary\<AmmoDataSO, int\> 형태로 관리한다. 또한, 현재 선택된 탄약이 무엇인지 currentSelectedAmmo 상태를 가진다.  
* '탄약 교체' 행동 (6번 슬롯): 6번 슬롯의 '탄약 교체' 어빌리티는 일반 공격/스킬과 다르다. 이 어빌리티를 실행하면, 유닛의  탄약 인벤토리를 보여주고 currentSelectedAmmo 상태를 변경하는 특수 UI를 호출한다  
* 탄약 소모: '주무기 사격'과 같은 무기 어빌리티는 Costs 필드에 { ResourceType: Ammo, Amount: 1 }을 가진다. 어빌리티 실행 시,  
*   시스템은 유닛의 currentSelectedAmmo 종류의 탄약이 인벤토리에 있는지 확인하고, 있다면 1만큼 차감한다. 탄약이 없다면 해당 어빌리티는 비활성화된다.  
* 

### 

# **11.0. 턴 행동 규칙 (Turn Action Logic)**

\*\*"쏘면 끝난다"\*\*는 대원칙 하에 병과별 예외를 둔다.

## **11.1. 액티브 턴 결정 공식 (TS: Turn Speed)**

모든 유닛은 고유의 **TS(Turn Speed)** 수치를 가지며, 이 수치가 0에 먼저 도달하는 순서대로 턴을 획득한다.

* **TS 산출 공식:** Final\_TS \= (Base\_Agility \* Random\_Weight) \+ Morale\_Bonus \- Action\_Penalty  
  * **Base\_Agility:** 유닛의 기본 민첩성.  
  * **Random\_Weight:** 0.8 \~ 1.2 사이의 난수 (턴 순서의 가변성 부여).  
  * **Morale\_Bonus:** 사기(Morale)가 높을수록 가산점 부여.  
  * **Action\_Penalty:** 직전 턴에서 수행한 행동의 무게 (아래 11.2 참조).

## **11.2. 행동별 페널티 (Action Cost / Penalty)**

행동을 적게 남길수록 다음 턴이 돌아오는 속도가 늦어진다.

| 수행 행동 | TS 페널티 (예시) | 비고 |
| :---: | :---: | :---: |
| **대기 (Wait)** | **\-10** | 아무것도 안 하고 턴 종료 시 가장 빠르게 복귀. |
| **이동만 수행** | **최대 \-40** | **상대적 피로도** 적용. `(기본 페널티10 + (사용한 이동력 / 최대 이동력)*30` 이는 유닛의 한계치에 가까운 이동을 할수록 다음 턴이 기하급수적으로 늦어짐을 의미함. |
| **공격만 수행** | **\-60** | 이동 없이 제자리 사격 시. |
| **이동 \+ 공격** | **\-100** | 모든 행동 기회 소진 시 가장 늦게 복귀. |
| **아이템 사용** | **\-30** | 소모품 종류에 따라 차등 적용. |
| **피격 시** | **이번 턴에 적용된 FinalTSpenalty의 10%/20%** | 일반 피격시/크리티컬 피격시 즉시 TS 누적 이동이라는 개념에 상당한 패널티를 주어 이동을 했음에도 제대로 된 곳으로 이동하지 못하였을 경우, 커다란 패널티를 입힘. 또한 일부러 턴을 넘기는 등의 전략적 플레이도 가능 내 턴에 피격시 즉시 TS를 깎지 않고 `Pool`에 누적 → **EndTurn() 호출 시점에 총합을 계산**하여 다음 턴 TS 배치에 반영. |

## 

## **11.3. 턴 스케줄러 로직 (Scheduler Logic)**

1. **계산:** 유닛의 행동이 종료되는 즉시 Action\_Penalty를 적용하여 Next\_Turn\_Tick을 계산한다.  
2. **정렬:** TurnManager는 모든 유닛을 Next\_Turn\_Tick이 낮은 순서(오름차순)로 실시간 재정렬한다.  
3. **호출:** 가장 상단에 있는 유닛에게 조작 권한을 부여한다.  
   * 

## **11.4. 병과별 행동 제약표 (Class Constraints)**

| 병과 | 무기/스킬 | 시퀀스 (A → B) | 가능 여부 | 로직 설명 |
| :---- | :---- | :---- | :---- | :---- |
| **공통** | 주무기 | 이동→ 사격 | **O 가능** | 표준 플레이. 사격 후 턴 종료됨. |
|  |  | 사격→ 이동 | **X 불가** | 주무기 사격 시 EndTurn() 호출됨. |
| **저격병** | **저격총** | 이동 → 사격 | **X 불가** | 저격총은 Move 후 사용 불가 제약. 권총은 가능 |
|  |  | 사격 → 이동 | **X 불가** | 사격 시 EndTurn() 호출됨. |
|  | **권총** | 이동→ 사격 | **O 가능** | 권총은 이동 패널티 없음. |
|  |  | 사격 → 이동 | **O 가능** | 권총은 EndTurn() 호출 안 함. (스카웃처럼 행동 가능) |
| **정찰병** | 주무기 | 이동→ 사격 | **O 가능** |  |
|  |  | 사격 → 이동 | **O 가능** | 정찰병 패시브: 사격이 EndTurn()을 호출하지 않음. |

---

## **11.5. 타임라인 UI 및 피드백 (Timeline & Delay)**

* **실시간 타임라인:** 화면 중단(또는 우측)에 '기준선(Center Line)'이 있고, TS 수치에 따라 좌/우(또는 상/하)로 초상화가 흘러가는 방식. 유닛의 `TS` 점수가 낮을수록 상단(다음 턴 예정)에 위치함.  
* 초상화 **Long Press(누르고 있기)** 시 해당 유닛으로 카메라 포커스 이동   
*  **개인 식별 시스템:**  
  * **배경색: 아군(Blue), 적군(Red)으로 피아 식별.**  
  * **식별자: 초상화 내 텍스트(P1, E1 등) 표시.**  
  * **하이라이트: 타임라인 초상화 마우스 오버/클릭 시 전장의 해당 유닛 발밑에 인디케이터 활성화.**  
* **턴 밀기 (Turn Delay):** **턴 주인공 여부**에 따라 차등 적용.  
  * 내 턴이 아닐 때 피격: 즉시 타임라인 순서가 밀림.  
  * 내 턴일 때 피격(경계 사격 등): 현재 행동은 유지하되, 다음 턴의 복귀 시간이 늦어짐.

# **12.0. 소모품 사용 로직 (Consumable Logic)**

### **12.1. 아이템 사용 규칙**

* **비용:** 소모품 사용은 행동 기회를 소모하지 않으나, 턴당 사용 횟수 제한(예: 1회)을 두어 무분별한 사용을 방지한다.

# **13.0. 특수 게임플레이 시스템 (Special Gameplay Systems)**

전투의 변수와 깊이를 더하는 추가적인 심리 및 지휘 시스템

## **13.1. \[13.1. Neural Sync & Survival System\]**

* 개요: 모든 유닛(아군/적군)은 'NS' 수치를 가지며, 전투 상황에 따라 변동한다.  
* 기존 '사기' 시스템을 '뉴럴 싱크'로 명칭 변경 및 데이터 통합.  
* 변동 요인:  
  * 감소: 아군/동료 사망, 치명타 피격, 적 지휘관의 특수 기술 피격 시.  
  * 회복: 적 사살, 치명타 공격 성공, 아군 지휘관의 격려 기술 사용 시.  
* 패닉 상태 (Panic State): 사기가 특정 임계점 50% 이하 도달 시 확률 주사위 (Virtue 10% / Affliction 90%).  
* 50% 도달 후 Affiction 상태가 될 경우 명령 불능, 도주의 형태가 되며 30% 도달시 아군 오사의 확률이 생기며 0% 도달 시 자해를 시작하며 사기가 다시 회복되어 30%  이상이 될 때까지 매 턴마다 자해를 하고 턴을 마침.  
* 사기에 따라 QTE 시스템의 난이도에 영향을 끼친다.  
* 상태 이상 (Unit Condition):  
  * **Normal:** 정상 상태.  
  * **Incapacitated:** 행동 불능 (기절/부상 등으로 턴 상실).  
  * **Fleeing:** 도주 (통제 불능 상태로 맵 밖으로 이동 시도).  
  * **FriendlyFire:** 광란 (피아 식별 없이 가장 가까운 대상 공격).  
  * **SelfHarm:** 자해 (자신의 턴에 스스로에게 데미지를 입히고 턴 종료).  
    

## **13.2. 지휘관 시스템 (Commander System)**

* 개요: 일부 적 유닛은 '지휘관' 속성을 가지며, 전장 내 다른 일반 유닛들의 행동 패턴에 영향을 준다  
* 효과 :   
  AI 강화 \- 지휘관이 생존해 있는 동안, 시야 내의 모든 일반 유닛 AI의 수준이 향상된다.  
  지휘관 사망 시 사기에 막대한 불이익.

**13.2.2. AI 아키타입 (Archetypes)** \> 1\. **Aggressive (돌격형):** 근접 거리 점수 가중치 높음. 산탄총 효율 극대화 지점 선호.

2\. **Tactical (전술형):** 엄폐 및 각도 계수(AngleFactor)가 낮은 지점(측면) 선호.

3\. **Sniper (저격형):** 원거리 및 고지대(HeightFactor) 가중치 높음.

**13.2.3. 의사결정 방식:** 초기 단계에서는 Utility AI를 사용하여 행동별 점수를 산출하며, 추후 딥러닝을 통해 최적 가중치 산출 예정.